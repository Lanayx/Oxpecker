namespace Oxpecker.OpenApi

open System
open System.Collections.Generic
open System.Text.Json.Serialization.Metadata
open System.Threading
open System.Threading.Tasks
open Microsoft.AspNetCore.OpenApi
open Microsoft.OpenApi
open FSharp.Control
open type Microsoft.AspNetCore.Http.TypedResults

module private Helpers =

    let (|FSharpOptionKind|_|) (t: Type) =
        if t.IsGenericType then
            let gtd = t.GetGenericTypeDefinition()
            if gtd = typedefof<option<_>> || gtd = typedefof<ValueOption<_>> then
                Some(t.GetGenericArguments()[0])
            else
                None
        else
            None

    let (|OptionalProperties|_|) (ctx: OpenApiSchemaTransformerContext) =
        let result = ResizeArray()
        for propertyInfo in ctx.JsonTypeInfo.Properties do
            match propertyInfo.PropertyType with
            | FSharpOptionKind innerType ->
                result.Add((propertyInfo, innerType))
            | _ ->
                ()
        if result.Count > 0 then Some(result) else None

    /// Union an existing JsonSchemaType with `null` (OpenAPI 3.1), and also drives `nullable: true` for 3.0.
    let unionWithNull (t: Nullable<JsonSchemaType>) : Nullable<JsonSchemaType> =
        if t.HasValue then
            let combined =
                LanguagePrimitives.EnumOfValue((int t.Value) ||| (int JsonSchemaType.Null))
            Nullable<JsonSchemaType>(combined)
        else
            // Leave as null; writer will omit 'type'.
            Nullable()

type FSharpOptionSchemaTransformer() =
    interface IOpenApiSchemaTransformer with
        member _.TransformAsync
            (schema: OpenApiSchema, ctx: OpenApiSchemaTransformerContext, ct: CancellationToken)
            : Task =
            task {
                match ctx with
                | Helpers.OptionalProperties props ->
                    for propInfo, innerType in props do
                        let key = propInfo.Name
                        let! innerSchema = ctx.GetOrCreateSchemaAsync(innerType, null, ct)
                        let nullSchema = OpenApiSchema(Type = Nullable(JsonSchemaType.Null))
                        let newSchema = OpenApiSchema()
                        let items = ResizeArray<IOpenApiSchema>()
                        items.Add(nullSchema)
                        items.Add(innerSchema)
                        newSchema.OneOf <- items

                        // We replace the property schema if it exists (it should, generated by default generator).
                        match schema.Properties with
                        | null -> ()
                        | p when p.ContainsKey(key) -> p[key] <- newSchema
                        | _ -> ()

                | _ -> ()
            }
            :> Task
